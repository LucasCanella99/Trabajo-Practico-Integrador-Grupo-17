Para hacer el menu lo que decidimos hacer es hacer un modulo aparte con un menu de linea de comandos. Que va  a funcionar mediante inputs del usuario. Decidimos hacerlo asi porque
va a usar como parametro la red de servidores, que luego le va a ser proporcioanda en main.py, que ahi se va a importar la red(que maneja el mapa topopgrafico de servidores) y el ser-
vidor que es el que maneja toda la logica de movimiento de mensajes, registros, carpetas, etc.(utilizando funciones de la clase usuario).
Para lograr "extraer" el objeto servidor y utilizar sus funcionalidades hicimos una funcion auxiliar en el menu que realiza eso: get_servidor() que revisa que el correo sea valido y si lo
es extrae el dominio y luego extrae el objeto servidor asociado a ese dominio. Lo saca de un diccionario que almacena los servidores asociados a los dominios.

El metodo registrar_usuario() toma los datos mediante inputs del usuario y lo que hace registra usuario es: en vez de usar self. como hace en la instancia individual del servidor. Hace que 
se utilice la instancia de su servidor asociado a su dominio mediante la extraccion de get_servidor(). (Que lo extrae de un diccionario de distintas instancias de servidor. Cada una manejando su 
propio diccionario de usuarios, carpetas, etc.) Y utiliza las funcionalidades de ese servidor en especifico.

enviar_mensaje() el metodo enviar mensaje aplica la logica de enviar_mensaje pero en vez de utilizar el self para obtener el usuario del diccionario de la instancia servidor en especifico. Nuevamente
utiliza get_servidor() para extraer la instancia servidor asociada al mismo dominio y ahi aplicar la logica. Y para el destinatario si es el mismo dominio no es necesario el get_usuario() una segunda
vez porque ya el metodo "se pone en funcionamiento" al haber detectado la instancia con el remitente que es de donde se extrae primero la instancia asociada al dominio y si no es el mismo dominio se aplica
la simulacion de enrutamiento.

para listar_mensajes() tuvimos que modificar el listar_mensajes() de la clase servidor para que quede actualizado con los nuevo metodos de otras entregas de obtenet subcarpeta y listar los mensajes orde-
nados por prioridad de Carpeta. La logica es la misma que los otros metodos se piden entradas, se obtiene el servidor asociado al correo mediante get_servidor() y se llama al listar_mensajes() de esa instancia
Servidor en especifico

para crear_subcarpeta_principal() tuvimos que crear el metodo previamente en Servidor para delegarlo a la interfaz luego, utilizamos el metodo agregar_subcarpeta() de Carpeta en la carpeta principal del usuario(raiz) mediante
las entradas del usuario para crear la subcarpeta de la carpeta principal. Siempre usando el get_servidor() para obtener el servidor correspondiente al dominio del correo del usuario

para crear_subcarpeta_anidada() creamos tambien el nuevo metodo previamente en Servidor, utilizando el metodo crear_subcarpeta_anidada() de Usuario. Utilizando el get_servidor() y  mediante entradas del usuario se 
crea la subcarpeta anidada de la carpeta que quiera el usuario.

para mover_mensaje() con el metodo previamente creado en Servidor y usando get_servidor(). Reutilizamos el metodo mover_mensaje() de Carpeta y el metodo buscar_mensajes() de Carpeta para usar el primero del asunto
solicitado como Objeto mensaje y obtener_subcarpeta() para obtener el objeto Carpeta especificado como nombre en la entrada por el usuario.

contador_mensaje() Reutilizamosel recibir_mensaje() de Servidor, es un simple contador de mensajes en la bandeja principal.

Para la ejecucion de lainterfaz grafica de comandos hicimos que se imprima en consola un menu con todas las opciones disponibles y que mediante inputs un usuario primero elija la opcion despues la funcion que quiera 
utilizar, una opcion para una eleccion erronea o cuando quiera salir de la interfaz. Todo esto mediante un bucle con while.

Para probar el programa hicimos un modulo de pruebas main.py donde creamos las instancias de los servidores(dominios) y que luego utilicen todos la misma red gracias al parametro del constructor de Servidor ya que 
esta pensado para que al crear una instancia tengan todos la misma variable sino crearia un mapa topografico distinto para cada uno y no se podria hacer la simulacion a un nivel externo, solo a un nivel local de cada 
servidor