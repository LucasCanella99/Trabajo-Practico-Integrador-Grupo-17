Elegimos utilizar el modulo heapq para implementar la cola de prioridades porque a comparación de una lista común al implementar 
un heap binario nos aseguramos que las operaciones de inserción y extracción de mensajes tengan un costo/complejidad algorítmica 
de  O(logN) o que significa que si la lista es muy grande y sigue creciendo el costo de las operaciones crece pero a un valor mu-
chísimo más bajo que lo haría como una lista normal. Que seria de un costo mucho más elevado O(N).
Para poder implentar la cola de prioridades en vez de una lista normal de mensajes en cada carpeta, a la clase Mensaje, tuvi-
mos que agregarle un parametro/atributo por defecto que es la prioridad, si es 0 (defecto) es normal y si es 1 es urgente.Por 
lo que seria listado más cerca del indice 0 en la nueva lista(cola de prioridad)

Despues en la clase servidor se determina que si el asunto del mensaje contiene urgente se le cambia la prioridad al mensaje
pasando a ser de prioridad = 1 y si no contiene la palabra urgente sigue como norma con prioridad = 0
Con esto, este en la carpeta que este si es urgente siempre va a tener prioridad a la hora de ser ordenado en la cola de priori-
dades. Que despues de el filtrado el mensaje va a ir a una carpeta en especifico con las reglas definidas por el usuario y si no
coincide con las reglas va por defecto a la bandeja de entrada y ahi igualmente va a serguir ordenado porque es una instancia de Car-
peta.

En la clase Carpeta en agregar_mensaje() vamos a hacer que el mensaje sea una tupla, con prioridad y el mensaje. Vamos a hacer que la prio-
ridad si es 1 al momento de agregar el mensaje a la heap binaria sea -1 para que este más cerca de la raiz, ya que el modulo heapq ordena a los 
hijos con prioridad más baja más cerca de la raiz, lo que necesitamos nosotros para que este más cerca del indice por eso lo implementamos de es-
ta manera. Esto lo realizamos con heapq.heappush() que hace ese "filtrado" de mensaje menor(prioridad) hacia arriba en la raiz, y como nosotros
pusimo -1 en urgente esos quedan más arriba y los que no son urgentes 0(que es mayor a 1) quedan más abajo.

En el metodo lista de mensajes, hacemos primero una copia de la lista de mensajes. Luego iteramos sobre esa lista de mensajes y en cada iteracion
se aplica el algoritmo heappop() que tiene un costo de O(NlogN) ya que "saca" y pone en la lista a mostrar el de más prioridad (-1, urgente) y a hacer
eso hace un ordenamiento que pone como raiz a su hijo de mayor prioridad como nueva raz, lo saca, hace el ordenamiento y asi todo con un costo de
O(log N).Por ultimo se muestra la lista de mensajes ordenda por prioridad.N es la cantidad de veces que "saca y reemplaza " el algoritmo y logN es el costo
de cada operación individualmente.